// Author: Stefan Hoenig
// gxfactry.cpp : Generated Factory class for configuration gxstndrd
// DO NOT EDIT THIS FILE !!!
#include "stdafx.h"
#ifdef _GXDLL
#undef AFXAPI_DATA
#define AFXAPI_DATA __based(__segname("_DATA"))
#endif
// Headers
#ifndef _GXCTRLI_H_
#include "gxctrli.h"
#endif
#ifndef _GXTWND_H_
#include "gxtwnd.h"
#endif
#ifndef _GXWND_H_
#include "gxwnd.h"
#endif
#include "gxcvrcel.h"
#ifndef _GXFCTRY_H_
#include "gxfctry.h"
#endif
#ifdef _GXDLL
#undef AFXAPP_DATA
#define AFXAPP_DATA AFXAPI_DATA
#endif
#ifdef GX_USE_SEGMENTS
#pragma code_seg("GX_SEG_GXFACTRY")
#endif
#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif
#define new DEBUG_NEW
void AFXAPI GXInit(UINT uiMfcVersion, LPCTSTR pszLang, LPCTSTR pszPath)
{
	GXInit(uiMfcVersion, new CGXControlFactory, pszLang, pszPath);
}
void CGXControlFactory::InitializeGridComponents(CGXGridCore* pGrid)
{
	// InitializeGridComponents is called from CGXGridCore ctor.
	// There has no window been created for the grid. m_pGridWnd is NULL.
	// Don't use the pGrid->m_pGridWnd!
	pGrid;
	// General grid components - enable them in the control
	// factory so that all grids in your application behave
	// similar. You can enable/disable the behavior for individual
	// grid with CGXGridParam settings (e.g. EnableMoveRows, 
	// EnableSelection etc).
	pGrid->ImplementFindReplace();			// Find and Replace 
	pGrid->ImplementHideCells();			// Hiding rows and columns
	pGrid->ImplementAutoScroll();			// AutoScrolling, SpeedScrolling
	pGrid->ImplementResizeToFit();			// Resize Cells to fit size
	pGrid->ImplementUpdateHint();			// Update Hint mechanism
	pGrid->ImplementCoveredCells();			// Covered Cells
	pGrid->ImplementPrinting();				// Printing
	pGrid->ImplementUserSelectRange();		// Select cell ranges with mouse or keyboard
	pGrid->ImplementExcelLikeFrame();		// Excel-like Selection Frame
	pGrid->ImplementUserDragSelectRange();	// Drag selected rows or columns with mouse
	pGrid->ImplementUserResizeCells();		// Resize rows or columns with mouse
	pGrid->ImplementOptimizedUpdate();		// Optimized update for inserting, moving and removing rows and columms
	pGrid->ImplementMarkEditHeader();		// Outline row and column header of current cell
	pGrid->ImplementFreezeMenuHelper();		// FreezeRows, UnfreezeRows (and ..Cols) methods
	pGrid->ImplementDirectCopyMoveCells();	// Direct copying, moving of cells within one grid
	pGrid->ImplementTextDataExchange();		// CSV text file and clipboard data exchange
	pGrid->ImplementCutPaste();				// Cut, Copy and Paste methods
	pGrid->ImplementClearCells();			// ClearCells method
}
void CGXControlFactory::InitializeApplicationComponents()
{
	// General application wide components - other components
	// rely on some of these application wide components, e.g.
	CGXStyle::ImplementCompareSubset();		// CGXStyle and CGXFont's IsSubSet method
	CGXStyle::ImplementProfile();			// CGXStyle - read and write profile
	CGXData::ImplementCopyMoveCells();		// Direct copying and moving cells within grid in CGXData
	CGXCoveredCellPool::ImplementCoveredCellPool();	// Covered cells pool data structure
}
void CGXControlFactory::RegisterAllControls(CGXStylesMap* pStylesMap)
{
	pStylesMap;
	// Basic cell types
	pStylesMap->AddControl(GX_IDS_CTRL_EDIT);
	pStylesMap->AddControl(GX_IDS_CTRL_HEADER);
	pStylesMap->AddControl(GX_IDS_CTRL_TEXTFIT);
	pStylesMap->AddControl(GX_IDS_CTRL_COMBOBOX);
	pStylesMap->AddControl(GX_IDS_CTRL_ONEBASED);
	pStylesMap->AddControl(GX_IDS_CTRL_ZEROBASED);
	pStylesMap->AddControl(GX_IDS_CTRL_ONEBASED_EX);
	pStylesMap->AddControl(GX_IDS_CTRL_ZEROBASED_EX);
	pStylesMap->AddControl(GX_IDS_CTRL_STATIC);
	pStylesMap->AddControl(GX_IDS_CTRL_PUSHBTN);
	pStylesMap->AddControl(GX_IDS_CTRL_RADIOBTN);
	pStylesMap->AddControl(GX_IDS_CTRL_RADIOBTN3D);
	pStylesMap->AddControl(GX_IDS_CTRL_CHECKBOX);
	pStylesMap->AddControl(GX_IDS_CTRL_CHECKBOX3D);
	// Advanced
#if _MFC_VER >= 0x0400
#endif
	// Edit Misc
	pStylesMap->AddControl(GX_IDS_CTRL_SPINEDIT);
	pStylesMap->AddControl(GX_IDS_CTRL_HOTSPOT);
	pStylesMap->AddControl(GX_IDS_CTRL_SCROLLEDIT);
}
CGXControl* CGXControlFactory::CreateControl(UINT nID, CGXGridCore* pGrid)
{
	CGXControl* pControl = NULL;
	BOOL bWin32s = FALSE;
#if _MFC_VER >= 0x0400
	bWin32s = GXGetAppData()->bWin31;
#endif
	// create control on demand
	switch (nID)
	{
	case 0:
	default:
		GX_TRACEONCE(_T("Warning: Couldn't create cell type Id %u %s\n"), nID, (LPCTSTR) CGXResourceString(nID));
		NULL;
		// Fall through
	case GX_IDS_CTRL_EDIT:
		// default edit box
		pControl = new CGXEditControl(pGrid, GX_IDS_CTRL_EDIT);break;
	case GX_IDS_CTRL_STATIC:
		// use static cell as default if cell type is unknown
		pControl = new CGXStatic(pGrid);break;
	case GX_IDS_CTRL_HEADER:
		// default headers
		pControl = new CGXHeader(pGrid);break;
	case GX_IDS_CTRL_TEXTFIT:
		// Comboboxes
		// combobox only allows text input which fits the choice list
		pControl = new CGXComboBox(pGrid, GX_IDS_CTRL_TEXTFIT, GX_IDS_CTRL_TEXTFIT, GXCOMBO_TEXTFIT);
		break;
	case GX_IDS_CTRL_COMBOBOX:
		// combobox allows user to input any text
		pControl = new CGXComboBox(pGrid, GX_IDS_CTRL_COMBOBOX, GX_IDS_CTRL_COMBOBOX, GXCOMBO_NOTEXTFIT);
		break;
	case GX_IDS_CTRL_ONEBASED:
		// combobox uses an integer as cell value
		pControl = new CGXComboBox(pGrid, GX_IDS_CTRL_ONEBASED, GX_IDS_CTRL_ONEBASED, GXCOMBO_ONEBASED);
		break;
	case GX_IDS_CTRL_ZEROBASED:
		// combobox uses an integer as cell value
		pControl = new CGXComboBox(pGrid, GX_IDS_CTRL_ZEROBASED, GX_IDS_CTRL_ZEROBASED, GXCOMBO_ZEROBASED);
		break;
	case GX_IDS_CTRL_ONEBASED_EX:
			// use an integer as value and display choice as cell text
		pControl = new CGXComboBox(pGrid, GX_IDS_CTRL_ONEBASED_EX, GX_IDS_CTRL_ONEBASED_EX,
			GXCOMBO_ONEBASED|GXCOMBO_DISPLAYCHOICE);break;
	case GX_IDS_CTRL_ZEROBASED_EX:
			// use an zero-based integer as value and display choice as cell text
		pControl = new CGXComboBox(pGrid, GX_IDS_CTRL_ZEROBASED_EX, GX_IDS_CTRL_ZEROBASED_EX,
			GXCOMBO_ZEROBASED|GXCOMBO_DISPLAYCHOICE);break;
	case GX_IDS_CTRL_SPINEDIT:
		// Textcontrol with Spinbuttons
		pControl = new CGXSpinEdit(pGrid, GX_IDS_CTRL_SPINEDIT);break;
	case GX_IDS_CTRL_HOTSPOT:
		// Textcontrol with hotspot button
		pControl = new CGXHotSpotEdit(pGrid, GX_IDS_CTRL_HOTSPOT);break;
	case GX_IDS_CTRL_SCROLLEDIT:
		// Textcontrol with Vertical scrollbars
		pControl = new CGXVScrollEdit(pGrid, GX_IDS_CTRL_SCROLLEDIT);break;
	case GX_IDS_CTRL_PUSHBTN:
		// Push Button
		pControl = new CGXPushbutton(pGrid);break;
	case GX_IDS_CTRL_RADIOBTN:
		// Radio Buttons
		pControl = new CGXRadioButton(pGrid, FALSE /* normal Look */);break;
	case GX_IDS_CTRL_RADIOBTN3D:
		pControl = new CGXRadioButton(pGrid, TRUE /* 3d-Look */);break;
	case GX_IDS_CTRL_CHECKBOX:
		// Check Boxes
		pControl = new CGXCheckBox(pGrid, FALSE /* normal Look */);	break;
	case GX_IDS_CTRL_CHECKBOX3D:
		pControl = new CGXCheckBox(pGrid, TRUE /* 3d-Look */);break;
#if _MFC_VER >= 0x0400
#endif
	}
	return pControl;
}
void CGXControlFactory::RegisterAllUserAttributes(CGXStylesMap* pStylesMap)
{
	pStylesMap;
	CGXControl::AddUserAttributes(pStylesMap);
	CGXComboBox::AddUserAttributes(pStylesMap);
	CGXSpinEdit::AddUserAttributes(pStylesMap);
	CGXCheckBox::AddUserAttributes(pStylesMap);
#if _MFC_VER >= 0x0400
#endif
			// Tooltips
#if _MFC_VER >= 0x0400
		pStylesMap->AddUserAttribute(GX_IDS_UA_TOOLTIPTEXT,
			CGXStyle().SetWrapText(TRUE).SetAutoSize(TRUE));
#endif
}
void CGXControlFactory::RegisterWndClasses(HINSTANCE hInstance)
{
	hInstance;
	CGXGridWnd::RegisterClass(hInstance);
	// Tab Window
	CGXTabBeam::RegisterClass(hInstance);
	CGXTabWnd::RegisterClass(hInstance);
}
void CGXControlFactory::UnregisterWndClasses(HINSTANCE hInstance)
{
	hInstance;
	CGXGridWnd::UnregisterClass(hInstance);
	// Tab Window
	CGXTabBeam::UnregisterClass(hInstance);
	CGXTabWnd::UnregisterClass(hInstance);
}

